先找到了了一些资料：http://61.51.95.234:8060/pages/viewpage.action?pageId=10322655

看一下然后汇总信息。

洲哥提供的多线程渲染的例子：http://xdpixel.com/how-a-multi-threaded-renderer-works/
- Update、Render（RHI）分开，Render延后一帧
- 需要注意线程间的同步
- DX11、OGL、Vulcan的 native graphics api 都是被调用立即执行的
- 避免Update线程与Render线程出现资源的竞争，需要用到RingBuffer（无锁、线程安全、避免资源竞争）

这个例子的代码与之前在知乎上看到的思路(https://zhuanlan.zhihu.com/p/44116722) 是一致的，感觉很好理解，再进一步吧，看看别人在工程是怎么实现的。

https://github.com/bkaradzic/bgfx 里面的代码，暂时还没看到多线程的起作用的地方。但在官网的API上，看到了多线程的说明。

https://bkaradzic.github.io/bgfx/bgfx.html?highlight=multi#id1 encoder！跟Metal上的概念一致。那么下面的一个可能的方向，就是**学习DX12、Metal、Vulcan**等对多线程支持比较好的GraphicsAPI，了解一下他们是怎么运作的。

https://zhuanlan.zhihu.com/p/73381385 这篇文章分析了UE的多线程渲染流程。我想知道UE4是怎么处理对多线程渲染支持比较好的DX12与平平淡淡的OpenGL的差别的。主要是CommandList这一块。UE4是如何封装的。

但是首先我需要了解DX12是如何运作的。

那么接下来学习下DX12吧。https://www.zhihu.com/question/34795960

下载网速好差，改下hosts看下有没有反应，http://tool.chinaz.com/dns?type=1&host=github.global.ssl.fastly.net&ip=：
```
69.171.229.11 github.global.ssl.fastly.net
52.74.223.119 github.com
124.134.126.254 download.visualstudio.microsoft.com
```

初始化D3D12 https://www.braynzarsoft.net/viewtutorial/q16390-03-initializing-directx-12 ，有一些关键的概念
- Command Lists
- PSO
- Bundles
- Command Queues
- Command Allocators
- Descriptor Heaps
- Root Signatures
- Resource Barriers
- Fences and Fence Events

看了一遍，新术语仍然是懵逼的，先继续往下走。

PSO必须要设置的：
- Shader Bytecode
- Input Layout
- Primitive Topology Type
- Blend State
- Rasterizer State
- DS State
- RenderTargets
- Number of renderTargets
- Multi-Sampling
- Stream Output Buffer
- The Root Signature ?
可以在其他时候设置的:
- Resource Binding
- Viewports
- Scissor Rectangles
- Blend Fator
- Depth/Stencil reference value
- IA primitive topology order/adjacency
  
#### Root Signatures
定义shader用的数据，如Constants、Descriptors,Descriptor Tables。
- Root Parameters
- Root Arguments

constantbuffer起作用的伪代码
``` c++
// this is our gpu memory where resource heaps are actually at
ResourceHeap resourceHeaps[];

// this is the descriptor heap
DescriptorHeap descriptorHeaps[];

// this is our register list
register b[]; // constant buffer register list
register t[]; // shader resource register list
register u[]; // uav register list

// our root signature is the parameter list to the pipeline
RenderTargetList RunPipeline(RootSignature rootSignature)
{
    // loop through each descriptor table
    for(int i = 0; i < rootSignature.DescriptorTables.length; i++)
    {
        int startRegister = rootSignature.DescriptorTables[i].Range.BaseShaderRegister;
        for(int k = 0; k < rootSignature.DescriptorTables[i].Range.length; k++)
        {
            // if its a constant buffer descriptor table use b registers
            if(rootSignature.DescriptorTables[i].Range[k].RangeType == D3D12_DESCRIPTOR_RANGE_TYPE_CBV)
            {
                // there are two indirections for descriptor tables
                b[startRegister + k] = GetResourcePointer(GetDescriptorFromTable(rootSignature.DescriptorTables[i].Range[k].descriptorIndex));
            }
            // use t registers for srv's
            else if(rootSignature.DescriptorTables[i].Range[k].RangeType == D3D12_DESCRIPTOR_RANGE_TYPE_SRV)
            {
                // there are two indirections for descriptor tables
                t[startRegister + k] = GetResourcePointer(GetDescriptorFromTable(rootSignature.DescriptorTables[i].Range[k].descriptorIndex));
            }
            // ... then uav's and samplers
        }
    }
    
    // loop through each root descriptor
    for(int i = 0; i < rootSignature.RootDescriptors.length; i++)
    {
        // set registers for root descriptors. There is only one redirection here
    }
    
    // loop through each root constant
    for(int i = 0; i < rootSignature.RootConstants.length; i++)
    {
        // set registers to root constants. root constants have no indirections, making them the fastest
        // to access, but the number of them are limited by the root signature parameter limit.
    }
    
    VertexInput vi = null;
    if(rootSignature.D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)
    {
        // If we specify to use the input assembler in the root signature, the IA will run and assembler
        // all the geometry we have bound to it, then pass the vertices to the vertex shader
        // it is possible to not use the input assembler at all, but instead draw a certain number of vertices
        // and use their index to differentiate them, then create more goemetry in the geometry shader.
        vi = RunInputAssembler(); 
    }
    
    // here we run the bound vertex shader
    VertexOutput vo = RunVertexShader(vi);
    
    // ... run other stages
}

// heres an example of a vertex shader now
VertexOutput RunVertexShader(VertexInput vi)
{
    // this constant buffer is bound to register b0. We must
    // make sure that the bound root signature has a parameter that
    // sets the b0 register
    cbuffer ConstantBuffer : register(b0)
    {
        float4 positionOffset;
    };
    
    // here is our vertex shader function. We use positionOffset, which is defined in a constant buffer.
    // This constant buffer is updated by the root signature. We must make sure that the root signature contains
    // a parameter for register b0, since that is what the constant buffer is bound to.
    float4 main(float3 pos : POSITION) : SV_POSITION
    {
        output.pos = float4(input.pos, 1.0f);
        output.color = input.color;
        return float4(pos.x + positionOffset.x, pos.y + positionOffset.y + pos.z + positionOffset.z, 1.0);
    }
}
```

DirectX 12引入了Fence对象，来实现GPU到CPU的同步。Fence是一种无锁的同步机制，它符合GPU端到CPU端轻量的同步原语要求。基本上，通信只需要一个整型的变量即可实现。

代码如下所示：

表5.3：创建Fence对象

// 创建一个Fence，其中fenceValue为初始值

ComPtr<ID3D12Fence> pFence;

pDevice->CreateFence(fenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&pFence)));

通过Fence实现的同步分为两种，第一种是CPU端的线程查询当前Fence的值，从而得到GPU端执行任务的进度：

表5.4：通过查询Fence上的值实现同步

pCommandQueue->Signal(pFence.Get(), fenceValue);

 

// 由CPU端查询Fence上的完成值（进度）

// 如果比fenceValue小，则调用DoOtherWork

if (pFence->GetCompletedValue() < fenceValue)

{

DoOtherWork();

}

另一种是CPU端线程可以要求GPU在Fence上的值达到指定值时，将此线程唤醒以达到同步的目的，配合其它Win32的API，可以满足诸多同步要求。

代码示例如下：

表5.5：通过指定Fence上的值实现同步

if (pFence->GetCompletedValue() < fenceValue)

{

pFence->SetEventOnCompletion(fenceValue, hEvent);

WaitForSingleObject(hEvent, INFINITE);

}

 看完 https://gameinstitute.qq.com/community/detail/102957 中的多线程渲染部分，感觉已经清晰了不少。这个多线程渲染，与想要的Rendering Thread不太一样。
- 可以先做一个多线程的例子，如多线程更新资源，多线程提交资源，多线程绘制。

具体怎么着，等学到那一块的时候再想把，往以后引擎要实现的那种结构上靠。

https://software.intel.com/sites/default/files/managed/b5/34/DX12%20WhitePaper_v2.pdf  这个白皮书不错。

opengl 多线程： https://blog.csdn.net/hanbingfengying/article/details/38782043

引擎目前需要的是渲染线程，而不是多线程渲染。

## 额外
- https://www.daugaard.org/blog/writing-a-fast-and-versatile-spsc-ring-buffer/